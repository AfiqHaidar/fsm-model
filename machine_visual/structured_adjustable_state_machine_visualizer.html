<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple State Machine Visualizer</title>
    <script type="text/javascript">
        // Sample data embedded directly in the file
        const sampleData = {
            "narcolepticSuperhero": {
                "NarcolepticSuperheroes": [
                    {
                        "name": "SleepyMan",
                        "initial_state": "asleep",
                        "states": [
                            "asleep", "tired", "hanging out", "hungry", "sweaty", "saving the world"
                        ],
                        "triggers": [
                            "wake_up", "work_out", "eat", "distress_call", "complete_mission", "clean_up", "nap"
                        ],
                        "transitions": [
                            { "trigger": "wake_up", "source": "asleep", "dest": "hanging out" },
                            { "trigger": "work_out", "source": "hanging out", "dest": "hungry" },
                            { "trigger": "eat", "source": "hungry", "dest": "hanging out" },
                            { "trigger": "eat", "source": "hungry", "dest": "hungry" },
                            { "trigger": "distress_call", "source": "*", "dest": "saving the world" },
                            { "trigger": "complete_mission", "source": "saving the world", "dest": "sweaty" },
                            { "trigger": "clean_up", "source": "sweaty", "dest": "asleep" },
                            { "trigger": "clean_up", "source": "sweaty", "dest": "hanging out" },
                            { "trigger": "nap", "source": "*", "dest": "asleep" }
                        ]
                    }
                ]
            },
            "webActivity": {
                "WebActivityMachine": [
                    {
                        "name": "Web_activity_sample",
                        "initial_state": "google.com",
                        "states": [
                            "google.com", "youtube.com", "youtube.com/watch", "download whatsapp",
                            "whatsapp.com/download", "WhatsApp.dmg"
                        ],
                        "triggers": [
                            "performed_google_search", "accessed_website_link", "downloaded_file"
                        ],
                        "transitions": [
                            { "trigger": "accessed_website_link", "source": "google.com", "dest": "youtube.com" },
                            { "trigger": "accessed_website_link", "source": "youtube.com", "dest": "youtube.com/watch" },
                            { "trigger": "performed_google_search", "source": "google.com", "dest": "download whatsapp" },
                            { "trigger": "accessed_website_link", "source": "download whatsapp", "dest": "whatsapp.com/download" },
                            { "trigger": "downloaded_file", "source": "whatsapp.com/download", "dest": "WhatsApp.dmg" }
                        ]
                    }
                ]
            }
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        .header {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .config-panel {
            padding: 15px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .layout-panel {
            padding: 10px;
            background-color: #eee;
            border-bottom: 1px solid #ddd;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .main-container {
            display: flex;
            flex: 1;
            min-height: 500px;
        }
        .sidebar {
            width: 250px;
            padding: 15px;
            background-color: #f9f9f9;
            overflow-y: auto;
            border-right: 1px solid #ddd;
        }
        #graph-container {
            flex: 1;
            position: relative;
        }
        #network {
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        .sample-button {
            background-color: #2196F3;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        select, input {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        textarea {
            width: 100%;
            min-height: 150px;
            font-family: monospace;
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        #status-message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
        }
        .success {
            background-color: #e8f5e9;
            color: #2e7d32;
        }
        .error {
            background-color: #ffebee;
            color: #c62828;
        }
        .layout-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 15px;
        }
        h2, h3 {
            margin-top: 10px;
            margin-bottom: 10px;
        }
        #node-details {
            background-color: #f0f8ff;
            border-radius: 4px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        #node-details ul {
            margin-top: 5px;
            padding-left: 20px;
        }
        .locked-node {
            border: 2px dashed #ff6347 !important;
        }
        .positioning-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .positioning-controls button {
            flex: 1;
            min-width: 100px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>State Machine Visualizer</h2>
        <button id="save-image-btn">Save as PNG</button>
    </div>
    
    <div class="config-panel">
        <div>
            <h3>Sample Data:</h3>
            <button class="sample-button" onclick="loadSampleData('narcolepticSuperhero')">Narcoleptic Superhero</button>
            <button class="sample-button" onclick="loadSampleData('webActivity')">Web Activity</button>
        </div>
        
        <div>
            <h3>Or paste your JSON:</h3>
            <textarea id="json-input" placeholder="Paste your machine JSON data here..."></textarea>
            <button id="load-json-btn" style="margin-top: 10px;">Load JSON</button>
        </div>
    </div>
    
    <div class="layout-panel">
        <div class="layout-group">
            <label for="layout-type">Layout:</label>
            <select id="layout-type">
                <option value="grid">Grid</option>
                <option value="hierarchical">Hierarchical</option>
                <option value="force">Force-Directed</option>
            </select>
        </div>
        
        <div class="layout-group">
            <label for="node-shape">Node Shape:</label>
            <select id="node-shape">
                <option value="box">Box</option>
                <option value="ellipse">Ellipse</option>
                <option value="circle">Circle</option>
                <option value="diamond">Diamond</option>
            </select>
        </div>
        
        <div class="layout-group">
            <label for="edge-style">Edge Style:</label>
            <select id="edge-style">
                <option value="straight">Straight</option>
                <option value="curved">Curved</option>
            </select>
        </div>
        
        <div class="layout-group">
            <label for="grid-spacing">Spacing:</label>
            <input type="number" id="grid-spacing" min="50" max="500" value="150" style="width: 60px;">
        </div>
        
        <button id="apply-layout-btn">Apply Layout</button>
        <button id="reset-view-btn">Reset View</button>
    </div>
    
    <div class="layout-panel" style="background-color: #f0f0f0;">
        <h3 style="margin-right: 15px;">Node Positioning:</h3>
        <button id="toggle-lock-btn">Toggle Lock All</button>
        <button id="lock-selected-btn">Lock Selected</button>
        <button id="unlock-selected-btn">Unlock Selected</button>
        <button id="save-positions-btn">Save Positions</button>
        <div class="layout-group">
            <label for="load-positions-input">Load Positions:</label>
            <input type="file" id="load-positions-input" accept=".json">
        </div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <h3>Machine Info</h3>
            <div id="machine-info">
                <p>No machine loaded</p>
            </div>
            
            <div id="node-details" style="margin-top: 15px; border-top: 1px solid #ddd; padding-top: 15px;">
                <p>Click on a node to see details</p>
            </div>
            
            <h3>Legend</h3>
            <div>
                <p>🔵 Regular State</p>
                <p>🟢 Initial State</p>
                <p>🔴 Dead End State</p>
                <p>🔒 Locked Position</p>
                <p>🔓 Movable Position</p>
            </div>
            
            <div id="status-message"></div>
        </div>
        
        <div id="graph-container">
            <div id="network"></div>
        </div>
    </div>
    
    <script>
        // DOM elements
        const jsonInput = document.getElementById('json-input');
        const loadJsonBtn = document.getElementById('load-json-btn');
        const saveImageBtn = document.getElementById('save-image-btn');
        const resetViewBtn = document.getElementById('reset-view-btn');
        const layoutType = document.getElementById('layout-type');
        const nodeShape = document.getElementById('node-shape');
        const edgeStyle = document.getElementById('edge-style');
        const gridSpacing = document.getElementById('grid-spacing');
        const applyLayoutBtn = document.getElementById('apply-layout-btn');
        const machineInfo = document.getElementById('machine-info');
        const statusMessage = document.getElementById('status-message');
        
        // Variables
        let network = null;
        let currentMachine = null;
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        
        // Load sample data
        function loadSampleData(key) {
            try {
                const data = sampleData[key];
                if (!data) throw new Error("Sample data not found");
                
                // Find first machine type
                const machineType = Object.keys(data)[0];
                if (!machineType || !Array.isArray(data[machineType]) || !data[machineType][0]) {
                    throw new Error("Invalid machine data format");
                }
                
                // Get first machine
                currentMachine = data[machineType][0];
                visualizeMachine(currentMachine);
                updateMachineInfo(currentMachine);
                showStatus(`Loaded sample: ${currentMachine.name}`, 'success');
            } catch (error) {
                showStatus(`Error loading sample: ${error.message}`, 'error');
            }
        }
        
        // Load JSON from textarea
        loadJsonBtn.addEventListener('click', () => {
            try {
                if (!jsonInput.value.trim()) {
                    showStatus("Please enter JSON data", 'error');
                    return;
                }
                
                const data = JSON.parse(jsonInput.value);
                
                // Find first machine type
                const machineType = Object.keys(data)[0];
                if (!machineType || !Array.isArray(data[machineType]) || !data[machineType][0]) {
                    throw new Error("Invalid machine data format");
                }
                
                // Get first machine
                currentMachine = data[machineType][0];
                visualizeMachine(currentMachine);
                updateMachineInfo(currentMachine);
                showStatus(`Loaded machine: ${currentMachine.name}`, 'success');
            } catch (error) {
                showStatus(`Error parsing JSON: ${error.message}`, 'error');
            }
        });
        
        // Apply layout
        applyLayoutBtn.addEventListener('click', () => {
            if (currentMachine) {
                visualizeMachine(currentMachine);
                showStatus("Layout applied", 'success');
            } else {
                showStatus("No machine loaded", 'error');
            }
        });
        
        // Toggle node locking
        document.getElementById('toggle-lock-btn').addEventListener('click', () => {
            if (!network || !currentMachine) return;
            
            const nodeIds = nodes.getIds();
            const lockedNodes = nodeIds.filter(id => {
                const node = nodes.get(id);
                return node.fixed && node.fixed.x && node.fixed.y;
            });
            
            const allLocked = lockedNodes.length === nodeIds.length;
            
            // Toggle - if all are locked, unlock all. Otherwise lock all
            nodeIds.forEach(id => {
                nodes.update({
                    id: id,
                    fixed: {
                        x: !allLocked,
                        y: !allLocked
                    },
                    shapeProperties: {
                        borderDashes: !allLocked
                    }
                });
            });
            
            showStatus(allLocked ? "All nodes unlocked" : "All nodes locked", 'success');
        });
        
        // Lock selected nodes
        document.getElementById('lock-selected-btn').addEventListener('click', () => {
            if (!network) return;
            
            const selectedNodes = network.getSelectedNodes();
            if (selectedNodes.length === 0) {
                showStatus("No nodes selected", 'error');
                return;
            }
            
            selectedNodes.forEach(id => {
                nodes.update({
                    id: id,
                    fixed: {
                        x: true,
                        y: true
                    },
                    shapeProperties: {
                        borderDashes: true // Visual indicator for locked nodes
                    }
                });
            });
            
            showStatus(`Locked ${selectedNodes.length} selected nodes`, 'success');
        });
        
        // Unlock selected nodes
        document.getElementById('unlock-selected-btn').addEventListener('click', () => {
            if (!network) return;
            
            const selectedNodes = network.getSelectedNodes();
            if (selectedNodes.length === 0) {
                showStatus("No nodes selected", 'error');
                return;
            }
            
            selectedNodes.forEach(id => {
                nodes.update({
                    id: id,
                    fixed: {
                        x: false,
                        y: false
                    },
                    shapeProperties: {
                        borderDashes: false
                    }
                });
            });
            
            showStatus(`Unlocked ${selectedNodes.length} selected nodes`, 'success');
        });
        
        // Save node positions
        document.getElementById('save-positions-btn').addEventListener('click', () => {
            if (!network || !currentMachine) {
                showStatus("No machine loaded", 'error');
                return;
            }
            
            const nodePositions = {};
            nodes.forEach(node => {
                const position = network.getPositions([node.id])[node.id];
                nodePositions[node.id] = { x: position.x, y: position.y };
            });
            
            const positionsJson = JSON.stringify(nodePositions, null, 2);
            const blob = new Blob([positionsJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentMachine.name}_positions.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            showStatus("Node positions saved to JSON", 'success');
        });
        
        // Load node positions
        document.getElementById('load-positions-input').addEventListener('change', (event) => {
            if (!network || !currentMachine) {
                showStatus("No machine loaded", 'error');
                return;
            }
            
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const positions = JSON.parse(e.target.result);
                    
                    // Apply positions to nodes
                    Object.entries(positions).forEach(([nodeId, position]) => {
                        if (nodes.get(nodeId)) {
                            nodes.update({
                                id: nodeId,
                                x: position.x,
                                y: position.y,
                                fixed: {
                                    x: true,
                                    y: true
                                },
                                shapeProperties: {
                                    borderDashes: true
                                }
                            });
                        }
                    });
                    
                    network.redraw();
                    showStatus("Node positions loaded", 'success');
                } catch (error) {
                    showStatus(`Error loading positions: ${error.message}`, 'error');
                }
            };
            
            reader.readAsText(file);
        });
        
        // Reset view
        resetViewBtn.addEventListener('click', () => {
            if (network) {
                network.fit({
                    animation: {
                        duration: 1000,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        });
        
        // Show status message
        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = '';
            statusMessage.classList.add(type);
        }
        
        // Update machine info
        function updateMachineInfo(machine) {
            if (!machine) {
                machineInfo.innerHTML = '<p>No machine loaded</p>';
                return;
            }
            
            const stateCount = machine.states ? machine.states.length : 0;
            const transitionCount = machine.transitions ? machine.transitions.length : 0;
            
            machineInfo.innerHTML = `
                <p><strong>Name:</strong> ${machine.name || 'Unknown'}</p>
                <p><strong>Initial State:</strong> ${machine.initial_state || 'None'}</p>
                <p><strong>States:</strong> ${stateCount}</p>
                <p><strong>Transitions:</strong> ${transitionCount}</p>
            `;
        }
        
        // Visualize the machine
        function visualizeMachine(machine) {
            if (!machine || !machine.states || !machine.transitions) {
                showStatus('Invalid machine data', 'error');
                return;
            }
            
            // Clear existing data
            nodes.clear();
            edges.clear();
            
            // Get layout options
            const layout = layoutType.value;
            const shape = nodeShape.value;
            const smooth = edgeStyle.value === 'curved';
            const spacing = parseInt(gridSpacing.value) || 150;
            
            // Find states with no outgoing transitions (dead ends)
            const statesWithOutgoing = new Set();
            machine.transitions.forEach(t => {
                if (t.source !== '*') {
                    statesWithOutgoing.add(t.source);
                }
            });
            
            // Create nodes
            machine.states.forEach((state, index) => {
                const isInitial = state === machine.initial_state;
                const isDeadEnd = !statesWithOutgoing.has(state) && state !== machine.initial_state;
                
                nodes.add({
                    id: state,
                    label: state,
                    shape: shape,
                    color: {
                        background: isInitial ? '#90EE90' : (isDeadEnd ? '#FFCCCB' : '#ADD8E6'),
                        border: isInitial ? '#006400' : (isDeadEnd ? '#B22222' : '#4682B4')
                    },
                    borderWidth: isInitial ? 3 : 1,
                    shapeProperties: {
                        borderDashes: false // Will be set to true for locked nodes
                    }
                });
            });
            
            // Create edges with transitions
            const processedEdges = new Map();
            
            machine.transitions.forEach(transition => {
                if (transition.source === '*') {
                    // Handle wildcard transitions
                    machine.states.forEach(state => {
                        if (state !== transition.dest) {
                            const edgeKey = `${state}-${transition.dest}`;
                            
                            if (!processedEdges.has(edgeKey)) {
                                processedEdges.set(edgeKey, {
                                    id: edgeKey,
                                    from: state,
                                    to: transition.dest,
                                    label: transition.trigger,
                                    arrows: 'to',
                                    smooth: smooth
                                });
                            }
                        }
                    });
                } else {
                    // Regular transition
                    const edgeKey = `${transition.source}-${transition.dest}`;
                    
                    if (!processedEdges.has(edgeKey)) {
                        processedEdges.set(edgeKey, {
                            id: edgeKey,
                            from: transition.source,
                            to: transition.dest,
                            label: transition.trigger,
                            arrows: 'to',
                            smooth: smooth
                        });
                    } else {
                        // Multiple triggers between same states
                        const edge = processedEdges.get(edgeKey);
                        if (edge.label.indexOf(transition.trigger) === -1) {
                            edge.label += `, ${transition.trigger}`;
                        }
                    }
                }
            });
            
            // Add edges to dataset
            edges.add(Array.from(processedEdges.values()));
            
            // Set node positions based on layout
            if (layout === 'grid') {
                const cols = Math.ceil(Math.sqrt(machine.states.length));
                machine.states.forEach((state, index) => {
                    const row = Math.floor(index / cols);
                    const col = index % cols;
                    
                    nodes.update({
                        id: state,
                        x: col * spacing,
                        y: row * spacing,
                        fixed: {
                            x: false, // Start unlocked in grid mode so nodes can be dragged
                            y: false
                        },
                        shapeProperties: {
                            borderDashes: false
                        }
                    });
                });
            }
            
            // Create options based on layout
            let options = {
                nodes: {
                    font: { size: 14 },
                    margin: 10,
                    widthConstraint: { maximum: 150 }
                },
                edges: {
                    font: { size: 12 },
                    smooth: smooth
                },
                interaction: {
                    hover: true,
                    navigationButtons: true,
                    keyboard: true,
                    dragNodes: true,
                    dragView: true,
                    zoomView: true,
                    selectable: true, 
                    multiselect: true
                },
                manipulation: {
                    enabled: false
                }
            };
            
            // Layout-specific options
            if (layout === 'hierarchical') {
                options.layout = {
                    hierarchical: {
                        direction: 'UD', // Up to Down
                        sortMethod: 'directed',
                        nodeSpacing: spacing / 2,
                        levelSeparation: spacing
                    }
                };
                options.physics = { enabled: false };
            } else if (layout === 'grid') {
                options.physics = { enabled: false };
            } else { // force-directed
                options.physics = {
                    enabled: true,
                    solver: 'forceAtlas2Based',
                    forceAtlas2Based: {
                        gravitationalConstant: -100,
                        springLength: spacing,
                        springConstant: 0.08
                    },
                    stabilization: {
                        iterations: 100
                    }
                };
            }
            
            // Create network
            const container = document.getElementById('network');
            
            if (network) {
                // Destroy existing network
                network.destroy();
            }
            
            network = new vis.Network(container, { nodes, edges }, options);
            
            // Add drag end event to support custom positioning
            network.on("dragEnd", function(params) {
                if (params.nodes.length > 0) {
                    params.nodes.forEach(nodeId => {
                        const position = network.getPositions([nodeId])[nodeId];
                        // Update node position and lock it
                        nodes.update({
                            id: nodeId,
                            x: position.x,
                            y: position.y,
                            fixed: {
                                x: true,
                                y: true
                            },
                            shapeProperties: {
                                borderDashes: true // Visual indicator for locked nodes
                            }
                        });
                    });
                    showStatus(`Node position updated and locked`, 'success');
                }
            });
            
            // Show node info on selection
            network.on("click", function(params) {
                if (params.nodes.length === 1) {
                    const nodeId = params.nodes[0];
                    const node = nodes.get(nodeId);
                    const isLocked = node.fixed && node.fixed.x && node.fixed.y;
                    
                    // Show transitions for this state
                    let html = `<p><strong>Selected:</strong> ${nodeId}</p>`;
                    html += `<p><strong>Status:</strong> ${isLocked ? '🔒 Locked' : '🔓 Unlocked'}</p>`;
                    
                    // Find outgoing transitions
                    if (currentMachine && currentMachine.transitions) {
                        const outgoing = currentMachine.transitions.filter(t => 
                            t.source === nodeId || t.source === '*'
                        );
                        
                        if (outgoing.length > 0) {
                            html += '<p><strong>Outgoing Transitions:</strong></p><ul>';
                            outgoing.forEach(t => {
                                html += `<li>${t.trigger} → ${t.dest}</li>`;
                            });
                            html += '</ul>';
                        } else {
                            html += '<p><strong>No outgoing transitions</strong></p>';
                        }
                        
                        // Find incoming transitions
                        const incoming = currentMachine.transitions.filter(t => 
                            t.dest === nodeId && t.source !== '*'
                        );
                        
                        if (incoming.length > 0) {
                            html += '<p><strong>Incoming Transitions:</strong></p><ul>';
                            incoming.forEach(t => {
                                html += `<li>${t.source} → ${t.trigger}</li>`;
                            });
                            html += '</ul>';
                        }
                    }
                    
                    document.getElementById('node-details').innerHTML = html;
                } else {
                    document.getElementById('node-details').innerHTML = '<p>Click on a node to see details</p>';
                }
            });
            
            // Fit the network
            setTimeout(() => {
                network.fit({
                    animation: {
                        duration: 1000,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }, 100);
        }
        
        // Initialize with empty network
        const container = document.getElementById('network');
        const data = { nodes, edges };
        network = new vis.Network(container, data, {});
        
        // Initialize with sample data
        loadSampleData('narcolepticSuperhero');
    </script>
</body>
</html>
                        "name": "SleepyMan",
                        "initial_state": "asleep",
                        "states": [
                            "asleep", "tired", "hanging out", "hungry", "sweaty", "saving the world"
                        ],
                        "triggers": [
                            "wake_up", "work_out", "eat", "distress_call", "complete_mission", "clean_up", "nap"
                        ],
                        "transitions": [
                            { "trigger": "wake_up", "source": "asleep", "dest": "hanging out" },
                            { "trigger": "work_out", "source": "hanging out", "dest": "hungry" },
                            { "trigger": "eat", "source": "hungry", "dest": "hanging out" },
                            { "trigger": "eat", "source": "hungry", "dest": "hungry" },
                            { "trigger": "distress_call", "source": "*", "dest": "saving the world" },
                            { "trigger": "complete_mission", "source": "saving the world", "dest": "sweaty" },
                            { "trigger": "clean_up", "source": "sweaty", "dest": "asleep" },
                            { "trigger": "clean_up", "source": "sweaty", "dest": "hanging out" },
                            { "trigger": "nap", "source": "*", "dest": "asleep" }
                        ]
                    }
                ]
            },
            "webActivity": {
                "WebActivityMachine": [
                    {
                        "name": "Web_activity_sample",
                        "initial_state": "google.com",
                        "states": [
                            "google.com", "youtube.com", "youtube.com/watch", "download whatsapp",
                            "whatsapp.com/download", "WhatsApp.dmg"
                        ],
                        "triggers": [
                            "performed_google_search", "accessed_website_link", "downloaded_file"
                        ],
                        "transitions": [
                            { "trigger": "accessed_website_link", "source": "google.com", "dest": "youtube.com" },
                            { "trigger": "accessed_website_link", "source": "youtube.com", "dest": "youtube.com/watch" },
                            { "trigger": "performed_google_search", "source": "google.com", "dest": "download whatsapp" },
                            { "trigger": "accessed_website_link", "source": "download whatsapp", "dest": "whatsapp.com/download" },
                            { "trigger": "downloaded_file", "source": "whatsapp.com/download", "dest": "WhatsApp.dmg" }
                        ]
                    }
                ]
            }
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        .header {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .config-panel {
            padding: 15px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .layout-panel {
            padding: 10px;
            background-color: #eee;
            border-bottom: 1px solid #ddd;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .main-container {
            display: flex;
            flex: 1;
            min-height: 500px;
        }
        .sidebar {
            width: 250px;
            padding: 15px;
            background-color: #f9f9f9;
            overflow-y: auto;
            border-right: 1px solid #ddd;
        }
        #graph-container {
            flex: 1;
            position: relative;
        }
        #network {
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        .sample-button {
            background-color: #2196F3;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        select, input {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        textarea {
            width: 100%;
            min-height: 150px;
            font-family: monospace;
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        #status-message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
        }
        .success {
            background-color: #e8f5e9;
            color: #2e7d32;
        }
        .error {
            background-color: #ffebee;
            color: #c62828;
        }
        .layout-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 15px;
        }
        h2, h3 {
            margin-top: 10px;
            margin-bottom: 10px;
        }
        #node-details {
            background-color: #f0f8ff;
            border-radius: 4px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        #node-details ul {
            margin-top: 5px;
            padding-left: 20px;
        }
        .locked-node {
            border: 2px dashed #ff6347 !important;
        }
        .positioning-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .positioning-controls button {
            flex: 1;
            min-width: 100px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>State Machine Visualizer</h2>
        <button id="save-image-btn">Save as PNG</button>
    </div>
    
    <div class="config-panel">
        <div>
            <h3>Sample Data:</h3>
            <button class="sample-button" onclick="loadSampleData('narcolepticSuperhero')">Narcoleptic Superhero</button>
            <button class="sample-button" onclick="loadSampleData('webActivity')">Web Activity</button>
        </div>
        
        <div>
            <h3>Or paste your JSON:</h3>
            <textarea id="json-input" placeholder="Paste your machine JSON data here..."></textarea>
            <button id="load-json-btn" style="margin-top: 10px;">Load JSON</button>
        </div>
    </div>
    
    <div class="layout-panel">
        <div class="layout-group">
            <label for="layout-type">Layout:</label>
            <select id="layout-type">
                <option value="grid">Grid</option>
                <option value="hierarchical">Hierarchical</option>
                <option value="force">Force-Directed</option>
            </select>
        </div>
        
        <div class="layout-group">
            <label for="node-shape">Node Shape:</label>
            <select id="node-shape">
                <option value="box">Box</option>
                <option value="ellipse">Ellipse</option>
                <option value="circle">Circle</option>
                <option value="diamond">Diamond</option>
            </select>
        </div>
        
        <div class="layout-group">
            <label for="edge-style">Edge Style:</label>
            <select id="edge-style">
                <option value="straight">Straight</option>
                <option value="curved">Curved</option>
            </select>
        </div>
        
        <div class="layout-group">
            <label for="grid-spacing">Spacing:</label>
            <input type="number" id="grid-spacing" min="50" max="500" value="150" style="width: 60px;">
        </div>
        
        <button id="apply-layout-btn">Apply Layout</button>
        <button id="reset-view-btn">Reset View</button>
    </div>
    
    <div class="layout-panel" style="background-color: #f0f0f0;">
        <h3 style="margin-right: 15px;">Node Positioning:</h3>
        <button id="toggle-lock-btn">Toggle Lock All</button>
        <button id="lock-selected-btn">Lock Selected</button>
        <button id="unlock-selected-btn">Unlock Selected</button>
        <button id="save-positions-btn">Save Positions</button>
        <div class="layout-group">
            <label for="load-positions-input">Load Positions:</label>
            <input type="file" id="load-positions-input" accept=".json">
        </div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <h3>Machine Info</h3>
            <div id="machine-info">
                <p>No machine loaded</p>
            </div>
            
            <div id="node-details" style="margin-top: 15px; border-top: 1px solid #ddd; padding-top: 15px;">
                <p>Click on a node to see details</p>
            </div>
            
            <h3>Legend</h3>
            <div>
                <p>🔵 Regular State</p>
                <p>🟢 Initial State</p>
                <p>🔴 Dead End State</p>
                <p>🔒 Locked Position</p>
                <p>🔓 Movable Position</p>
            </div>
            
            <div id="status-message"></div>
        </div>
        
        <div id="graph-container">
            <div id="network"></div>
        </div>
    </div>
    
    <script>
        // DOM elements
        const jsonInput = document.getElementById('json-input');
        const loadJsonBtn = document.getElementById('load-json-btn');
        const saveImageBtn = document.getElementById('save-image-btn');
        const resetViewBtn = document.getElementById('reset-view-btn');
        const layoutType = document.getElementById('layout-type');
        const nodeShape = document.getElementById('node-shape');
        const edgeStyle = document.getElementById('edge-style');
        const gridSpacing = document.getElementById('grid-spacing');
        const applyLayoutBtn = document.getElementById('apply-layout-btn');
        const machineInfo = document.getElementById('machine-info');
        const statusMessage = document.getElementById('status-message');
        
        // Variables
        let network = null;
        let currentMachine = null;
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        
        // Load sample data
        function loadSampleData(key) {
            try {
                const data = sampleData[key];
                if (!data) throw new Error("Sample data not found");
                
                // Find first machine type
                const machineType = Object.keys(data)[0];
                if (!machineType || !Array.isArray(data[machineType]) || !data[machineType][0]) {
                    throw new Error("Invalid machine data format");
                }
                
                // Get first machine
                currentMachine = data[machineType][0];
                visualizeMachine(currentMachine);
                updateMachineInfo(currentMachine);
                showStatus(`Loaded sample: ${currentMachine.name}`, 'success');
            } catch (error) {
                showStatus(`Error loading sample: ${error.message}`, 'error');
            }
        }
        
        // Load JSON from textarea
        loadJsonBtn.addEventListener('click', () => {
            try {
                if (!jsonInput.value.trim()) {
                    showStatus("Please enter JSON data", 'error');
                    return;
                }
                
                const data = JSON.parse(jsonInput.value);
                
                // Find first machine type
                const machineType = Object.keys(data)[0];
                if (!machineType || !Array.isArray(data[machineType]) || !data[machineType][0]) {
                    throw new Error("Invalid machine data format");
                }
                
                // Get first machine
                currentMachine = data[machineType][0];
                visualizeMachine(currentMachine);
                updateMachineInfo(currentMachine);
                showStatus(`Loaded machine: ${currentMachine.name}`, 'success');
            } catch (error) {
                showStatus(`Error parsing JSON: ${error.message}`, 'error');
            }
        });
        
        // Apply layout
        applyLayoutBtn.addEventListener('click', () => {
            if (currentMachine) {
                visualizeMachine(currentMachine);
                showStatus("Layout applied", 'success');
            } else {
                showStatus("No machine loaded", 'error');
            }
        });
        
        // Toggle node locking
        document.getElementById('toggle-lock-btn').addEventListener('click', () => {
            if (!network || !currentMachine) return;
            
            const nodeIds = nodes.getIds();
            const lockedNodes = nodeIds.filter(id => {
                const node = nodes.get(id);
                return node.fixed && node.fixed.x && node.fixed.y;
            });
            
            const allLocked = lockedNodes.length === nodeIds.length;
            
            // Toggle - if all are locked, unlock all. Otherwise lock all
            nodeIds.forEach(id => {
                nodes.update({
                    id: id,
                    fixed: {
                        x: !allLocked,
                        y: !allLocked
                    }
                });
            });
            
            showStatus(allLocked ? "All nodes unlocked" : "All nodes locked", 'success');
        });
        
        // Lock selected nodes
        document.getElementById('lock-selected-btn').addEventListener('click', () => {
            if (!network) return;
            
            const selectedNodes = network.getSelectedNodes();
            if (selectedNodes.length === 0) {
                showStatus("No nodes selected", 'error');
                return;
            }
            
            selectedNodes.forEach(id => {
                nodes.update({
                    id: id,
                    fixed: {
                        x: true,
                        y: true
                    }
                });
            });
            
            showStatus(`Locked ${selectedNodes.length} selected nodes`, 'success');
        });
        
        // Unlock selected nodes
        document.getElementById('unlock-selected-btn').addEventListener('click', () => {
            if (!network) return;
            
            const selectedNodes = network.getSelectedNodes();
            if (selectedNodes.length === 0) {
                showStatus("No nodes selected", 'error');
                return;
            }
            
            selectedNodes.forEach(id => {
                nodes.update({
                    id: id,
                    fixed: {
                        x: false,
                        y: false
                    }
                });
            });
            
            showStatus(`Unlocked ${selectedNodes.length} selected nodes`, 'success');
        });
        
        // Save node positions
        document.getElementById('save-positions-btn').addEventListener('click', () => {
            if (!network || !currentMachine) {
                showStatus("No machine loaded", 'error');
                return;
            }
            
            const nodePositions = {};
            nodes.forEach(node => {
                const position = network.getPositions([node.id])[node.id];
                nodePositions[node.id] = { x: position.x, y: position.y };
            });
            
            const positionsJson = JSON.stringify(nodePositions, null, 2);
            const blob = new Blob([positionsJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentMachine.name}_positions.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            showStatus("Node positions saved to JSON", 'success');
        });
        
        // Load node positions
        document.getElementById('load-positions-input').addEventListener('change', (event) => {
            if (!network || !currentMachine) {
                showStatus("No machine loaded", 'error');
                return;
            }
            
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const positions = JSON.parse(e.target.result);
                    
                    // Apply positions to nodes
                    Object.entries(positions).forEach(([nodeId, position]) => {
                        if (nodes.get(nodeId)) {
                            nodes.update({
                                id: nodeId,
                                x: position.x,
                                y: position.y,
                                fixed: {
                                    x: true,
                                    y: true
                                }
                            });
                        }
                    });
                    
                    network.redraw();
                    showStatus("Node positions loaded", 'success');
                } catch (error) {
                    showStatus(`Error loading positions: ${error.message}`, 'error');
                }
            };
            
            reader.readAsText(file);
        });
        
        // Reset view
        resetViewBtn.addEventListener('click', () => {
            if (network) {
                network.fit({
                    animation: {
                        duration: 1000,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        });
        
        // Save as PNG
        saveImageBtn.addEventListener('click', () => {
            if (network) {
                try {
                    const canvas = network.canvas.frame.canvas;
                    const dataUrl = canvas.toDataURL('image/png');
                    
                    // Create download link
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = currentMachine ? `${currentMachine.name}.png` : 'state-machine.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    showStatus("Image saved", 'success');
                } catch (error) {
                    showStatus(`Error saving image: ${error.message}`, 'error');
                }
            } else {
                showStatus("No graph to save", 'error');
            }
        });
        
        // Show status message
        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = '';
            statusMessage.classList.add(type);
        }
        
        // Update machine info
        function updateMachineInfo(machine) {
            if (!machine) {
                machineInfo.innerHTML = '<p>No machine loaded</p>';
                return;
            }
            
            const stateCount = machine.states ? machine.states.length : 0;
            const transitionCount = machine.transitions ? machine.transitions.length : 0;
            
            machineInfo.innerHTML = `
                <p><strong>Name:</strong> ${machine.name || 'Unknown'}</p>
                <p><strong>Initial State:</strong> ${machine.initial_state || 'None'}</p>
                <p><strong>States:</strong> ${stateCount}</p>
                <p><strong>Transitions:</strong> ${transitionCount}</p>
            `;
        }
        
                    // Visualize the machine
        function visualizeMachine(machine) {
            if (!machine || !machine.states || !machine.transitions) {
                showStatus('Invalid machine data', 'error');
                return;
            }
            
            // Clear existing data
            nodes.clear();
            edges.clear();
            
            // Get layout options
            const layout = layoutType.value;
            const shape = nodeShape.value;
            const smooth = edgeStyle.value === 'curved';
            const spacing = parseInt(gridSpacing.value) || 150;
            
            // Find states with no outgoing transitions (dead ends)
            const statesWithOutgoing = new Set();
            machine.transitions.forEach(t => {
                if (t.source !== '*') {
                    statesWithOutgoing.add(t.source);
                }
            });
            
            // Create nodes
            machine.states.forEach((state, index) => {
                const isInitial = state === machine.initial_state;
                const isDeadEnd = !statesWithOutgoing.has(state) && state !== machine.initial_state;
                
                nodes.add({
                    id: state,
                    label: state,
                    shape: shape,
                    color: {
                        background: isInitial ? '#90EE90' : (isDeadEnd ? '#FFCCCB' : '#ADD8E6'),
                        border: isInitial ? '#006400' : (isDeadEnd ? '#B22222' : '#4682B4')
                    },
                    borderWidth: isInitial ? 3 : 1,
                    shapeProperties: {
                        borderDashes: false // Will be set to true for locked nodes
                    }
                });
            });
            
            // Create edges with transitions
            const processedEdges = new Map();
            
            machine.transitions.forEach(transition => {
                if (transition.source === '*') {
                    // Handle wildcard transitions
                    machine.states.forEach(state => {
                        if (state !== transition.dest) {
                            const edgeKey = `${state}-${transition.dest}`;
                            
                            if (!processedEdges.has(edgeKey)) {
                                processedEdges.set(edgeKey, {
                                    id: edgeKey,
                                    from: state,
                                    to: transition.dest,
                                    label: transition.trigger,
                                    arrows: 'to',
                                    smooth: smooth
                                });
                            }
                        }
                    });
                } else {
                    // Regular transition
                    const edgeKey = `${transition.source}-${transition.dest}`;
                    
                    if (!processedEdges.has(edgeKey)) {
                        processedEdges.set(edgeKey, {
                            id: edgeKey,
                            from: transition.source,
                            to: transition.dest,
                            label: transition.trigger,
                            arrows: 'to',
                            smooth: smooth
                        });
                    } else {
                        // Multiple triggers between same states
                        const edge = processedEdges.get(edgeKey);
                        if (edge.label.indexOf(transition.trigger) === -1) {
                            edge.label += `, ${transition.trigger}`;
                        }
                    }
                }
            });
            
            // Add edges to dataset
            edges.add(Array.from(processedEdges.values()));
            
            // Set node positions based on layout
            if (layout === 'grid') {
                const cols = Math.ceil(Math.sqrt(machine.states.length));
                machine.states.forEach((state, index) => {
                    const row = Math.floor(index / cols);
                    const col = index % cols;
                    
                    nodes.update({
                        id: state,
                        x: col * spacing,
                        y: row * spacing,
                        fixed: {
                            x: false, // Start unlocked in grid mode so nodes can be dragged
                            y: false
                        },
                        shapeProperties: {
                            borderDashes: false
                        }
                    });
                });
            }
            
            // Create options based on layout
            let options = {
                nodes: {
                    font: { size: 14 },
                    margin: 10,
                    widthConstraint: { maximum: 150 }
                },
                edges: {
                    font: { size: 12 },
                    smooth: smooth
                },
                interaction: {
                    hover: true,
                    navigationButtons: true,
                    keyboard: true,
                    dragNodes: true,
                    dragView: true,
                    zoomView: true,
                    selectable: true, 
                    multiselect: true
                },
                manipulation: {
                    enabled: false
                }
            };: { maximum: 150 }
                },
                edges: {
                    font: { size: 12 },
                    smooth: smooth
                },
                interaction: {
                    hover: true,
                    navigationButtons: true,
                    keyboard: true,
                    dragNodes: true,
                    dragView: true,
                    zoomView: true,
                    selectable: true, 
                    multiselect: true
                },
                manipulation: {
                    enabled: false
                }
            };: { maximum: 150 }
                },
                edges: {
                    font: { size: 12 },
                    smooth: smooth
                },
                interaction: {
                    hover: true,
                    navigationButtons: true,
                    keyboard: true
                }
            };
            
            // Layout-specific options
            if (layout === 'hierarchical') {
                options.layout = {
                    hierarchical: {
                        direction: 'UD', // Up to Down
                        sortMethod: 'directed',
                        nodeSpacing: spacing / 2,
                        levelSeparation: spacing
                    }
                };
                options.physics = { enabled: false };
            } else if (layout === 'grid') {
                options.physics = { enabled: false };
            } else { // force-directed
                options.physics = {
                    enabled: true,
                    solver: 'forceAtlas2Based',
                    forceAtlas2Based: {
                        gravitationalConstant: -100,
                        springLength: spacing,
                        springConstant: 0.08
                    },
                    stabilization: {
                        iterations: 100
                    }
                };
            }
            
            // Create network
            const container = document.getElementById('network');
            
            if (network) {
                // Destroy existing network
                network.destroy();
            }
            
            network = new vis.Network(container, { nodes, edges }, options);
            
            // Add drag end event to support custom positioning
            network.on("dragEnd", function(params) {
                if (params.nodes.length > 0) {
                    params.nodes.forEach(nodeId => {
                        const position = network.getPositions([nodeId])[nodeId];
                        // Update node position and lock it
                        nodes.update({
                            id: nodeId,
                            x: position.x,
                            y: position.y,
                            fixed: {
                                x: true,
                                y: true
                            }
                        });
                    });
                    showStatus(`Node position updated and locked`, 'success');
                }
            });
            
            // Show node info on selection
            network.on("click", function(params) {
                if (params.nodes.length === 1) {
                    const nodeId = params.nodes[0];
                    const node = nodes.get(nodeId);
                    const isLocked = node.fixed && node.fixed.x && node.fixed.y;
                    
                    // Show transitions for this state
                    let html = `<p><strong>Selected:</strong> ${nodeId}</p>`;
                    html += `<p><strong>Status:</strong> ${isLocked ? '🔒 Locked' : '🔓 Unlocked'}</p>`;
                    
                    // Find outgoing transitions
                    if (currentMachine && currentMachine.transitions) {
                        const outgoing = currentMachine.transitions.filter(t => 
                            t.source === nodeId || t.source === '*'
                        );
                        
                        if (outgoing.length > 0) {
                            html += '<p><strong>Outgoing Transitions:</strong></p><ul>';
                            outgoing.forEach(t => {
                                html += `<li>${t.trigger} → ${t.dest}</li>`;
                            });
                            html += '</ul>';
                        } else {
                            html += '<p><strong>No outgoing transitions</strong></p>';
                        }
                        
                        // Find incoming transitions
                        const incoming = currentMachine.transitions.filter(t => 
                            t.dest === nodeId && t.source !== '*'
                        );
                        
                        if (incoming.length > 0) {
                            html += '<p><strong>Incoming Transitions:</strong></p><ul>';
                            incoming.forEach(t => {
                                html += `<li>${t.source} → ${t.trigger}</li>`;
                            });
                            html += '</ul>';
                        }
                    }
                    
                    document.getElementById('node-details').innerHTML = html;
                } else {
                    document.getElementById('node-details').innerHTML = '<p>Click on a node to see details</p>';
                }
            });
            
            // Fit the network
            setTimeout(() => {
                network.fit();
            }, 100);
        }
        
        // Initialize with empty network
        const container = document.getElementById('network');
        const data = { nodes, edges };
        network = new vis.Network(container, data, {});
        
        // Initialize with sample data
        loadSampleData('narcolepticSuperhero');
    </script>
</body>
</html>
